
//        https://www.youtube.com/watch?v=WgXnBPfprhA
//  Интерфейс Map представляет собой отображение или иначе говоря словарь, где каждый элемент представляет собой
//  пару ключ-значение.
//  При этом все ключи уникальны, в рамках одного объекта Map.
//

//
//package Theory_JAVA;
//
//import java.util.*;
//
//
//public class Java_classHashMap_interfaceMap {
//    public static void main(String[] args) {
//    Создаём коллекцию Map<ключ, значение>
//    В качестве ключа номер паспорта, а в качестве значения ФИО человека.

//        Map<Integer, String> persons = new HashMap<Integer, String>();                   // Создана пустая коллекция.

//    Теперь в коллекцию добавим значения.
//        persons.put(462731, "Пупкин Василий Васильевич");
//        persons.put(462741, "Пупкин Пётр Васильевич");
//        persons.put(462751, "Кукурузов Антон Васильевич");
//        persons.put(411098, "Кукурузов Роман Сергеевич");
//        persons.put(462781, "Пупкин Пётр Васильевич");
//_____________________________________________________________________________________________________________________
//    Как получить элементы из коллекции типа Map.
//        System.out.println(persons.get(2));                     // null (так как нет такого ключа)
//        System.out.println(persons.get(462741));                // Пупкин Пётр Васильевич
//        System.out.println(persons.keySet());                   // Получить весь набор ключей из коллекции
//        System.out.println(persons.values());                   // Получить набор всех значений из коллекции.
//        System.out.println(persons.replace(462741, "Переехал"));        // Замена элемента коллекции.
//        System.out.println(persons.get(462741));
//        System.out.println(persons.remove(462741));             // Удаление элемента из коллекции
//        System.out.println(persons.values());
//        System.out.println(persons.size());                     // Количество элементов в коллекции.
//        persons.clear();                                        // Удалить все элементы из коллекции.
//_____________________________________________________________________________________________________________________
//_______ ПЕРЕБОР КОЛЛЕКЦИИ ___________________________________________________________________________________________

//        for (Map.Entry<Integer, String> item: persons.entrySet()){
//            System.out.println("Ключ: "+item.getKey()+" Значение: "+item.getValue());
//        }
//}
//_____________________________________________________________________________________________________________________
//=====================================================================================================================
//__________ Collections API (устроёство, виды) _______________________________________________________________________
//
// https://www.youtube.com/watch?v=oxBVSD35gk0&list=PL3icsIflRkxRR54rCMCEECj3SP1EhU7cV&index=11&t=28s
//
//      Map - структура данных, в которой объекты хранятся связкой уникальный ключ - неуникальное значение.
//      Set - структура данных, в которой хранятся уникальные объекты (реализована с помощью Map).

//  При создании экземпляра класса HashSet, внутри создается экземпляр класса HashMap.
//____________________________
//  public HashSet(){
//      map = new HashMap<>();
//  }
//____________________________
//  public TreeSet(){
//      this(new TreeMap<E, Object>());
//  }
//____________________________
//  public boolean add(E e) {return map.put(e, PRESENT)==null;}
//____________________________
//
//______________________________________________________________________________________________________________________
//
//          HashMap - добавляет элементы в "корзины" не гарантируя порядка. Позволяет быстро доставать элементы и
//      хранить значения null (как key так и value).
//          LinkedHashMap - как HashMap, но хранит объекты в порядке добавления.
//          SortedMap - интерфейс. определяющий методы сортировки.
//          TreeMap - хранит объекты в отсортированном виде (по полю key).
//          HashTable - как HashMap, но синхронизован для многопоточности, не позволяет хранить null/
//
//__________________________________________________ HashMap __________________________________________________________
//          HashMap - добавляет элементы в "корзины" не гарантируя порядка. Позволяет быстро доставать элементы и
//      хранить значения null (как key так и value).
//
//_____ Внутри HashMap есть: __________________________________________________________________________________________
//      + Вложенный Класс Node<K,V>, содержащий поля:
//          1. final int hash. - хеш-код для объекта K key.
//          2. final K key. - неизменяемое значение ключа.
//          3. V value. - хранимое выражение.
//          4. Node<K,V>next. - ссылка на следующий элемент.
//      + int initialCapacity - начальный размер таблицы (16).
//      + float loadFactor - загруженность до расширения (0,75f).
//
//      table - таблица в HashMap, служит для хранения цепочек значений.
//      Представляет собой массив Node<K,V>[] table.
//      По умолчанию длина массива = 16.
//      (Map<K,V> someMap = new HashMap<>())
//      [0][1][2][3][4][5][6][7][8][9][10][11][12][13][14][15]
//      Trashold - пороговое значение количества элементов перед расширением (initialCapacity * loadFactor).
//
//_____ Добавление элемента ___________________________________________________________________________________________
//      Добавление элемента put(K,V) - константная операция(0(1)).
//      1. Вычисляется hash ключа.
//      2. Вычисляется индекс в массиве (index = (n-1) & hash) - деление по модулю.
//         Модуль - количество корзин внутри карты.
//      3. Создаётся экземпляр вложенного класса Node<K,V>
//      4. Если под этим индексом уже лежит элемент - проверить их на равенство ключей.
//      5. Если ключи равны - перезаписывается value.
//         Иначе - ссылка next добавляемого объекта ссылается на существующий.
//      6. Добавляется объект.
//
//_____ Получение элемента ____________________________________________________________________________________________
//      Получение элемента get(K) - константная/линейная операция (0(1)/0(n)).
//      1. Вычисляется hash ключа.
//      2. Вычисляется индекс в массиве (index = (n-1) & hash) - деление по модулю.
//      3. С помощью метода equls() сравниваем объекты в цепочке.
//      4. Если ключи совпадают - возвращается значение.
//      5. Если ключи не совпадают и ссылка next != null - переход к следующему Node<K,V>
//      6. Если ссылка next == null - возвращается null.
//
//_____________________________________________________________________________________________________________________
//
//    public static void main(String[] args) {
//        Map<Integer, String> map = new HashMap<>(16, 1.1f);     // Заполнение карты.
//        for(int i =16; i >= 0; i--){
//            map.put(i, ""+i);
//        }
//        System.out.println(map);
//    }
//=====================================================================================================================
//
//__________________________________________________ LinkedHashMap ____________________________________________________
//      LinkedHashMap - как HashMap, но хранит объекты в порядке добавления.
//
//      Внутри LinkedHashMap также есть:
//      +   Класс Entry<K,V>extends Node<K,V>, имеющий поля Entry<K,V>before, after. - ссылки на предыдущий и
//          следующий добавленный элементы.
//      +   boolean accessOrder - порядок элементов (false).
//              false - согласно вставке элементов, true - согласно частоте доступа к элементу (от меньшего к большему).
//
//      У LinkedHashMap есть псевдо-элемент header, значение которого null, а свойства after и before указывают на
//      первый и последний добавленный элемент.
//
//_____ Добавление элемента ___________________________________________________________________________________________
//      Добавление элемента put(K,V) - константная операция(0(1)).
//      1. Вычисляется hash ключа.
//      2. Вычисляется индекс в массиве (index = (n-1) & hash).
//      3. Создаётся экземпляр вложенного класса Node<K,V>.
//      4. Если под этим индексом уже лежит элемент - проверить их на равенство ключей.
//      5. Если ключи равны - перезаписывается value. Иначе - ссылка next добавляемого объекта ссылается на
//         существующий.
//      6. Изменяются ссылки before и after ближайших объектов.
//      7. Добавляется объект.
//
//_____ Получение элемента ____________________________________________________________________________________________
//      Получение элемента get(K) - константная/линейная операция (0(1)/0(n)).
//      1. Вычисляется hash ключа.
//      2. Вычисляется индекс в массиве (index = (n-1) & hash).
//      3. С помощью метода equls() сравниваем объекты в цепочке.
//      4. Если ключи совпадают - возвращается значение.
//      5. Если ключи не совпадают и ссылка next !=null - переход к следующему Node<K,V>.
//      6. Если ссылка next == null - возвращается null.
//
//_____________________________________________________________________________________________________________________
//
//    public static void main(String[] args) {
//        Map<Integer, String> map = new LinkedHashMap<>(16, 1.1f, true);     // Заполнение карты.
//        for(int i =16; i >= 0; i--){                // {header}[][][][3, K, V][][][6, K, V][]
//            map.put(i, ""+i);
//        }
//        map.get(3);
//        map.get(3);
//        map.get(3);
//        map.get(6);
//        map.get(9);
//
//        System.out.println(map);
//    }
//=====================================================================================================================
//
//__________________________________________________ TreeMap __________________________________________________________
//      TreeMap - хранит объекты в отсортированном виде (по полю key).
//      Внутри TreeMap реализовано красно-черное дерево, благодаря чему время доступа к элементам равно O(ln(n)).
//
//      Красно-черное дерево - сбалансированное бинарное дерево поиска.
//      +   Свойства бинарного дерева:
//          1.  Поддеревья тоже являются бинарными деревьями поиска.
//          2.  Для каждого узла левый потомок <узла, а правый потомок> узла.
//      +   Свойства красно-черного дерева:
//          1.  Каждый узел является либо красным либо черным.
//          2.  Главный корень дерева всегда черный.
//          3.  Листья - черные.
//          4.  Каждый красный узел должен иметь 2 дочерних черных узла.
//          5.  Пусть от корня к листьям должен содержать равное число черных узлов (черная высота).
//      +   Добавление элемента в красно-черное дерево (кратко):
//          1.  Элемент вствляется на позицию листа и окрашивается в красный цвет.
//          2.  Происходит проверка свойств и в случае несоответствия - перебалансировка.
//
//
//
//
//
//
//_____________________________________________________________________________________________________________________

//    public static void main(String[] args) {
//        Map<Integer, String> map = new TreeMap<>(Comparator.reverseOrder());
//        for(int i = 16; i >= 0; i--){
//            map.put(i, "" +i);
//        }
//        map.get(3);
//        map.get(3);
//        map.get(3);
//        map.get(6);
//        map.get(9);
//
//        System.out.println(map);
//
//
//
//    }
//
//
//
//
//
//
//
//
//
//
//}
